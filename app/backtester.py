import pandas as pd
import textwrap
import pandas_ta as ta
import numpy as np
from datetime import datetime
import logging

def run_backtest(strategy_code, ohlc_data, initial_capital=100):
    try:
        print(f"Initial Capital (Before Execution): {initial_capital}")  # Debugging

        # Ensure initial_capital is a number
        initial_capital = float(initial_capital)

        # Make sure the OHLC data has numeric values
        numeric_cols = ['open', 'high', 'low', 'close', 'volume']
        for col in numeric_cols:
            if col in ohlc_data.columns:
                ohlc_data[col] = pd.to_numeric(ohlc_data[col], errors='coerce')

        # Clean up strategy code - remove any potential markdown formatting
        strategy_code = strategy_code.replace("```python", "").replace("```", "").strip()

        # Wrap the strategy code dynamically
        wrapped_code = textwrap.dedent(f"""
{strategy_code}
        """)

        # Debugging: Print the dynamically generated strategy
        print("Generated Strategy Code:")
        print(wrapped_code)

        # Execution environment with initial_capital included
        exec_globals = {
            "pd": pd, 
            "ta": ta, 
            "np": np,
            "initial_capital": initial_capital  # Add initial_capital to the globals
        }
        
        # Execute the strategy code
        try:
            exec(wrapped_code, exec_globals)
        except SyntaxError as e:
            error_msg = f"Syntax error in strategy code: {str(e)}"
            print(error_msg)
            return {"error": error_msg}
        except Exception as e:
            error_msg = f"Error executing strategy code: {str(e)}"
            print(error_msg)
            return {"error": error_msg}

        # Ensure the strategy function exists
        trading_strategy = exec_globals.get("trading_strategy", None)
        if trading_strategy is None:
            raise ValueError("The strategy function was not correctly defined.")

        # Run the strategy
        df = trading_strategy(ohlc_data.copy())  # Ensure no mutation of original data

        # Validate DataFrame output
        if not isinstance(df, pd.DataFrame) or 'signal' not in df.columns:
            raise ValueError("Strategy did not return a valid DataFrame with a 'signal' column.")

        # Ensure the signal column has numeric values
        df['signal'] = pd.to_numeric(df['signal'], errors='coerce').fillna(0).astype(int)
        
        # Ensure price columns are numeric
        for col in numeric_cols:
            if col in df.columns:
                df[col] = pd.to_numeric(df[col], errors='coerce')

        print("DataFrame Returned by Strategy Function:")
        print(df.head())

        # Backtesting logic with enhanced metrics
        cash = initial_capital
        position = 0
        position_value = 0
        trade_log = []
        equity_curve = []
        entry_price = 0
        profitable_trades = 0
        losing_trades = 0
        total_profit = 0
        total_loss = 0
        
        # Check if we have enough signals to make a meaningful backtest
        signal_counts = df['signal'].value_counts()
        has_buy_signals = 1 in signal_counts and signal_counts[1] > 0
        has_sell_signals = -1 in signal_counts and signal_counts[-1] > 0
        
        if not has_buy_signals and not has_sell_signals:
            # Not enough signals found in the data
            error_msg = "No trading signals were generated by the strategy on the available data. Please adjust your strategy parameters to find entry/exit points in the given timeframe."
            logging.warning(error_msg)
            return {"error": error_msg, "signal_count": 0}

        # Ensure signals are properly sequenced and first signal is a buy
        # Get indexes of all signals
        buy_signals = df.index[df['signal'] == 1].tolist()
        sell_signals = df.index[df['signal'] == -1].tolist()
        
        if buy_signals and sell_signals:
            # If first sell is before first buy, remove it
            if sell_signals[0] < buy_signals[0]:
                df.loc[sell_signals[0], 'signal'] = 0

        # Calculate equity curve and trades
        for i, row in df.iterrows():
            # Skip rows with missing data
            if pd.isna(row['close']):
                continue
                
            # Get the close price and ensure it's a number
            close_price = float(row['close'])
            timestamp = row.name if isinstance(row.name, datetime) else row['timestamp']
            
            # Update position value
            if position > 0:
                position_value = position * close_price
            else:
                position_value = 0
                
            # Calculate equity
            equity = cash + position_value
            equity_curve.append({
                "timestamp": timestamp,
                "equity": equity,
                "close": close_price
            })
            
            # Process trading signal
            if row['signal'] == 1 and cash > 0:  # Buy
                print(f"BUY at {timestamp}, price: {close_price}, cash: {cash}")
                entry_price = close_price
                position = cash / close_price
                cash = 0
                trade_log.append({
                    "timestamp": str(timestamp),
                    "action": "BUY",
                    "price": close_price,
                    "position": position,
                    "equity": equity
                })

            elif row['signal'] == -1 and position > 0:  # Sell
                print(f"SELL at {timestamp}, price: {close_price}, position: {position}")
                cash = position * close_price
                trade_profit = ((close_price - entry_price) / entry_price) * 100
                if trade_profit > 0:
                    profitable_trades += 1
                    total_profit += trade_profit
                else:
                    losing_trades += 1
                    total_loss += abs(trade_profit)
                
                trade_log.append({
                    "timestamp": str(timestamp),
                    "action": "SELL",
                    "price": close_price,
                    "position": position,
                    "equity": equity,
                    "profit_pct": trade_profit
                })
                position = 0

        # Final calculations
        if df.empty:
            final_value = initial_capital
        else:
            last_close = float(df.iloc[-1]['close'])
            final_value = cash + (position * last_close)
            print(f"Final calculations: Cash: {cash}, Position: {position}, Last close: {last_close}")
            print(f"Final value: {final_value}")
            
        total_return = ((final_value - initial_capital) / initial_capital) * 100

        # Calculate additional metrics
        total_trades = profitable_trades + losing_trades
        win_rate = (profitable_trades / total_trades) * 100 if total_trades > 0 else 0
        
        # Calculate max drawdown
        equity_df = pd.DataFrame(equity_curve)
        if not equity_df.empty:
            equity_df['peak'] = equity_df['equity'].cummax()
            equity_df['drawdown'] = (equity_df['equity'] - equity_df['peak']) / equity_df['peak'] * 100
            max_drawdown = equity_df['drawdown'].min()
        else:
            max_drawdown = 0

        # Calculate Sharpe ratio (simplified)
        if len(equity_curve) > 1:
            equity_df['returns'] = equity_df['equity'].pct_change()
            sharpe_ratio = equity_df['returns'].mean() / equity_df['returns'].std() * np.sqrt(252) if equity_df['returns'].std() > 0 else 0
        else:
            sharpe_ratio = 0

        # Convert trade log to a DataFrame if it's not empty
        trade_log_df = pd.DataFrame(trade_log) if trade_log else pd.DataFrame(columns=["timestamp", "action", "price", "position", "equity", "profit_pct"])

        return {
            "initial_capital": initial_capital,
            "final_value": final_value,
            "return": total_return,
            "win_rate": win_rate,
            "total_trades": total_trades,
            "profitable_trades": profitable_trades,
            "losing_trades": losing_trades,
            "average_profit": total_profit / profitable_trades if profitable_trades > 0 else 0,
            "average_loss": total_loss / losing_trades if losing_trades > 0 else 0,
            "max_drawdown": max_drawdown,
            "sharpe_ratio": sharpe_ratio,
            "equity_curve": equity_curve,
            "trade_log": trade_log_df.to_dict(orient='records')
        }

    except SyntaxError as e:
        print(f"Syntax error in strategy code: {str(e)}")
        return {"error": f"Syntax error in strategy code: {str(e)}"}
    except Exception as e:
        print(f"Error during backtesting: {str(e)}")
        return {"error": str(e)}
